// Copyright 2022 The Drivers Cooperative. All rights reserved.
// Use of this source code is governed by a dual
// license that can be found in the LICENSE file.

package stat

import (
	"fmt"
	"runtime/metrics"
	"sort"
	"strings"
	"sync"
)

type rstat struct {
	samples []metrics.Sample
	list    rlist
}

type rnode struct {
	name string // node name: automatic
	path string // full path: /gc/cycles/automatic
	unit string // node unit: gc-cycles
	help string
	samp *metrics.Sample
	list *rlist
}

type rlist struct {
	nodes []*rnode
}

var rstatNames = [...][2]string{
	{"/gc/cycles/automatic:gc-cycles", "Count of completed GC cycles generated by the Go runtime."},
	{"/gc/cycles/forced:gc-cycles", "Count of completed GC cycles forced by the application."},
	{"/gc/heap/objects:objects", "Number of objects, live or unswept, occupying heap memory."},
	{"/memory/classes/total:bytes", "All memory mapped by the Go runtime into the current process as read-write."},
	{"/sched/goroutines:goroutines", "Count of live goroutines."},
}

//-----------------------------------------------------------------------------

func init() {
	Sys().Add("runtime", "Runtime metrics.", rstatFunc)
}

//-----------------------------------------------------------------------------

func rstatFunc(_ Context) (interface{}, error) {
	rs := getrstat()
	rs.read()
	return rs, nil
}

//-----------------------------------------------------------------------------
// Runtime Stat Pool
//-----------------------------------------------------------------------------

var rpool = sync.Pool{New: func() interface{} {
	return new(rstat)
}}

func getrstat() *rstat {
	rs, _ := rpool.Get().(*rstat)
	if len(rs.samples) == 0 {
		rs.init()
	}
	return rs
}

func (r *rstat) Release() {
	rpool.Put(r)
}

//-----------------------------------------------------------------------------

func (r *rstat) init() {
	n := len(rstatNames)
	r.samples = make([]metrics.Sample, n)
	for i := 0; i < n; i++ {
		name := &rstatNames[i]
		samp := &r.samples[i]
		samp.Name = name[0]
		r.list.addSample(samp, name[1])
	}
}

//-----------------------------------------------------------------------------

func (r *rstat) read() {
	metrics.Read(r.samples)
}

//-----------------------------------------------------------------------------

func (r *rstat) WriteJSON(b *JSONBuffer) error {
	return r.list.WriteJSON(b)
}

//-----------------------------------------------------------------------------
// runtime node
//-----------------------------------------------------------------------------

func (n *rnode) WriteJSON(b *JSONBuffer) error {
	if n.samp != nil {
		return n.jsonSamp(b)
	}
	if n.list != nil {
		return n.list.WriteJSON(b)
	}
	return fmt.Errorf("runtime metric %q is neither a sample nor a list", n.path)
}

//-----------------------------------------------------------------------------

func (n *rnode) addList() *rlist {
	n.list = new(rlist).alloc(8)
	return n.list
}

//-----------------------------------------------------------------------------

func (n *rnode) jsonSamp(b *JSONBuffer) (err error) {
	s := n.samp
	v := s.Value
	switch v.Kind() {
	case metrics.KindBad:
		slog.Warnf("bad runtime metric: %s", s.Name)
		b.Null()
	case metrics.KindUint64:
		b.Uint64(v.Uint64())
	case metrics.KindFloat64:
		err = b.Float64(v.Float64())
	default:
		b.Null()
	}
	return
}

//-----------------------------------------------------------------------------
// runtime list
//-----------------------------------------------------------------------------

func (r *rlist) WriteJSON(b *JSONBuffer) error {
	nodes := r.nodes
	if len(nodes) == 0 {
		b.EmptyObject()
		return nil
	}
	b.ObjectStart()
	for i := 0; i < len(nodes); i++ {
		node := nodes[i]
		b.Key(node.name, false)
		err := node.WriteJSON(b)
		if err != nil {
			return err
		}
		b.Comma()
	}
	b.ObjectClose()
	return nil
}

//-----------------------------------------------------------------------------

func (r *rlist) addSample(samp *metrics.Sample, help string) {
	path, unit := mustSplitLastByte(samp.Name, ':')
	tree, name := mustSplitLastByte(path, '/')
	list := r.makePath(tree)
	node := list.addNode(name, path, true)
	node.unit = unit
	node.help = help
	node.samp = samp
}

//-----------------------------------------------------------------------------

func (r *rlist) makePath(path string) *rlist {
	list := r
	splitFunc(path, '/', func(part string, prefix string) bool {
		node := list.node(part)
		if node == nil {
			node = list.addNode(part, prefix, false)
			list = node.addList()
			return true
		}
		if node.samp != nil {
			panic(fmt.Sprintf("list node name %q is taken by sample node", prefix))
		}
		list = node.list
		if list == nil {
			panic(fmt.Sprintf("list node %q list is nil", prefix))
		}
		return true
	})
	return list
}

//-----------------------------------------------------------------------------

func (r *rlist) addNode(name string, path string, check bool) *rnode {
	if check && r.find(name) != -1 {
		panic(fmt.Sprintf("node %q already exists at path %q", name, path))
	}
	node := &rnode{
		name: name,
		path: path,
	}
	r.nodes = append(r.nodes, node)
	r.sort()
	return node
}

func (r *rlist) alloc(size int) *rlist {
	r.nodes = make([]*rnode, 0, size)
	return r
}

//-----------------------------------------------------------------------------

func (r *rlist) Len() int {
	return len(r.nodes)
}

func (r *rlist) Less(i, j int) bool {
	return r.nodes[i].name < r.nodes[j].name
}

func (r *rlist) Swap(i, j int) {
	r.nodes[i], r.nodes[j] = r.nodes[j], r.nodes[i]
}

func (r *rlist) sort() {
	sort.Sort(r)
}

//-----------------------------------------------------------------------------

func (r *rlist) find(name string) int {
	a := r.nodes
	n := len(a)
	x := sort.Search(n, func(i int) bool {
		return a[i].name >= name
	})
	if x < n && a[x].name == name {
		return x
	}
	return -1
}

//-----------------------------------------------------------------------------

func (r *rlist) node(name string) *rnode {
	if x := r.find(name); x != -1 {
		return r.nodes[x]
	}
	return nil
}

//-----------------------------------------------------------------------------

func mustSplitLastByte(s string, c byte) (prefix, suffix string) {
	n := len(s)
	if n == 0 {
		panic("empty string argument")
	}
	prefix, suffix = splitLastByte(s, c)
	if len(suffix) > 0 {
		return
	}
	if s[n-1] == c {
		panic(fmt.Sprintf("split char %q is at the end of %q", c, s))
	}
	panic(fmt.Sprintf("split char %q not found in %q", c, s))
}

//-----------------------------------------------------------------------------

func splitLastByte(s string, c byte) (prefix, suffix string) {
	if x := strings.LastIndexByte(s, c); x != -1 {
		prefix = s[:x]
		suffix = s[x+1:]
		return
	}
	prefix = s
	return
}

//-----------------------------------------------------------------------------

func splitFunc(s string, c byte, f func(token string, prefix string) bool) {
	n := len(s)
	if n == 0 {
		return
	}
	i := 0
	if s[0] == c {
		i = 1
	}
	last := i
	for i < n {
		if s[i] != c {
			i++
			continue
		}
		if last < i {
			if !f(s[last:i], s[:i]) {
				return
			}
		}
		i++
		last = i
	}
	if last < i {
		f(s[last:i], s[:i])
	}
}
